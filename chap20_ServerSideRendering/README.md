# 서버 사이드 렌더링
* 웹 서비스의 초기 로딩 속도 개선, 캐싱 및 검색 엔진 최적화를 가능하게 해 주는 기술
* 초기 렌더링을 사용자의 브라우저가 아닌 서버 쪽에서 처리(UI를 서버에서 렌더링)
	- 사용자는 서버에서 렌더링한 html 결과물을 받아 그대로 사용
		+ 초기 로딩속도 개선
		+ 검색 엔진에서 크롤링도 문제 없음

## 장점
1. 검색 엔진 최적화
    - 리액트로 만든 SPA는 자바스크립트가 실행되지 않는 환경에서 페이지가 제대로 나타나지 않음
    - 서버에서 렌더링을 하면 검색엔진이 페이지의 내용을 제대로 수집해 갈 수 있음
2. 초기 렌더링 성능을 개선
    - 대기 시간 최소화
    - 사용자 경험 향상
        + 자바스크립트 파일 다운로드가 완료되지 않은 시점에서도 html상에 사용자가 볼수있는 콘텐츠가 존재

## 단점
1. 서버 리소스가 사용됨
    - 브라우저가 해야 할 일을 서버가 대신 처리하기 때문에
    - 서버 과부하가 발생할 수 있음
        + 캐싱과 로드 밸런싱을 통해 성능을 최적화
2. 프로젝트의 구조가 복잡해질 수 있음
3. 고려해야할 사항이 많아져 개발이 어려워질 수도 있음
    - 데이터 미리 불러오기
    - 코드 스플리팅과의 호환

## 서버 사이드 렌더링과 코드 스플리팅 충돌
* 별도의 호환 작업 없이 두 기술을 함께 적용하면, 아래의 흐름으로 페이지 깜박임이 발생
    1.서버 사이드 렌더링된 결과물이 브라우저에 나타남
    2.자바스크립트 파일 로딩 시작
    3.자바스크립트가 실행되면서 아직 불러오지 않는 컴포넌트를 null로 렌더링
    4.페이지에서 코드 스플리팅된 컴포넌트들이 사라짐
    5.코드 스플리팅된 컴포넌트들이 로딩된 이후 제대로 나타남
* Loadable Components 라이브러리를 통해 라우트 경로마다 필요한 모든 파일을 브라우저에서 렌더링하기 전에 미리 불러와야함

## 서버 사이드 렌더링 구현하기
```
yarn eject
```
* 웹팩 설정을 커스터마이징해 주어야 함
    - CRA로 만든 프로젝트는 웹팩 관련 설정이 기본적으로 모두 숨겨져 있기 때문에 eject 실행

## 엔트리 만들기
* entry : 웹팩에서 프로젝트를 불러올 때 가장 먼저 불러오는 파일
    - ex) index.js
* ReactDomServer.renderToString
    - 서버에서 리액트 컴포넌트를 렌더링 하기위한 함수
    - JSX를 넣어서 호출하면 렌더링 결과를 문자열로 반환

index.server.js
<hr />

## 웹팩 환경 설정 작성하기
* config/paths.js - 하단부
```
ssrIndexJs: resolveApp('src/index.server.js'), // 서버 사이드 렌더링 엔트리(불러올 파일의 경로)
ssrBuild: resolveApp('dist'), // 웹팩 처리 후 저장 경로(결과물 저장)
```
## 로더 설정
* 파일을 불러올 때 확장자에 맞게 필요한 처리를 해줌
    - 자바스크립트는 babel을 사용하여 트랜스파일링
    - CSS는 모든 CSS코드를 결합
    - 이미지 파일은 파일을 다른 경로에 따로 저장, 그 파일에 대한 경로를 자바스크립트에서 참조할 수 있게 함
    - CSS와 이미지는 무시할수 없지만 중요하지 않기 때문에 로더에서 별도로 설정하여 처리하지만 따로 결과물에 포함되지 않도록 구현 가능
## 번들링
* import 구문으로 라이브러리를 불러오며 빌드할 때 결과물 파일 안에 해당 라이브러리 관련 코드가 함께 번들링
* 서버에서는 node_modules를 통해 바로 불러와 사용할 수 있기 때문에 굳이 결과물 파일에 라이브러리가 들어 있지 않아도 됨
* webpack-node-externals 라이브러리를 통해 node_modules에서 불러오는것을 제외하고 번들링
```
yarn add webpack-node-externals
```
## 환경변수
* 프로젝트 내에서 process.env.NODE_ENV 값을 참조하여 현재 개발 환경인지 아닌지 확인

이상 config/webpack.config.server.js
<hr />

## 빌드
* 클라이언트에서 사용할 빌드 파일을 만드는 작업을 함

build.server.js
<hr />

## 서버 코드
```
yarn add express
```
* Express라는 Node.js 웹 프레임워크를 사용하여 웹서버를 만듦
    - 사용율이 가장 높음
    - 추후 정적 파일들을 호스팅할때도 쉽게 구현 가능
* StaticRouter
    - 주로 서버 사이드 렌더링 용도로 사용되는 라우터
    - props
        + location 값에 따라 라우팅
        + context 값을 사용하여 나중에 렌더링한 컴포넌트에 따라 HTTP 상태 코드를 설정
## 정적 파일
* static 미들웨어를 사용하여 서버를 통해 build에 있는 JS, CSS 정적 파일들에 접근
* JS와 CSS파일을 불러오도록 html에 코드를 삽입
    - 매번 빌드할때 마다 불러와야 하는 파일 이름이 다르기 때문에 빌드를 먼저 실행

index.server.js
<hr />

## 데이터 로딩
* 서버 사이드 렌더링을 구현할 때 해결하기가 매우 까다로운 문제 중 하나
* 서버의 경우 문자열 형태로 렌더링 하기 때문에 상태가 바뀌어도 자동으로 리렌더링 되지 않음
    - renderToString() 한번 더 호출
    - 서버 사이드 렌더링 시 데이터 로딩
    - redux-thunk or redux-saga 미들웨어를 사용하여 API를 호출

## 서버사이드 렌더링
* useEffect나 componentDidMout에서 설정한 작업이 호출 되지 않음
* 렌더링하기 전에 API를 요청한 뒤 스토어에 데이터를 담아야 함
    - 서버 환경에서 처리하려면 클래스형 컴포넌트의 constructor 메서드나 render함수에서 처리
    - 요청이 끝날 때까지 대기했다가 다시 렌더링 해주어야 함
* 서버 사이드 렌더링을 하는 과정에서 처리해야 할 작업들을 실행
    - 기다려야 하는 promise가 있다면 promise를 수집
    - 모든 프로미스 수집 후, 수집된 프로미스들이 끝날 때 까지 기다렸다가 다시 렌더링 하면 데이터가 채워진 상태로 컴포넌트들이 나타남
* renderToStaticMarkup
    - 리액트를 사용하여 정적인 페이지를 만들 때 사용
    - renderToString보다 처리 속도가 좀 더 빠름

lib/PreloadContext.js, index.server.js

## 서버 사이드 렌더링과 코드 스플리팅
* 서버 사이드 렌더링과 코드 스플리팅을 함께 사용할 때는 Loadable Components를 사용할 것을 권장
    - 서버 유틸 함수와 웹팩 플러그인, babel 플로그인을 제공
```
yarn add @loadable/component @loadable/server @loadable/webpack-plugin @loadable/babel-plugin
```
